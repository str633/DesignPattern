# 设计模式

## 原则

### 迪米特原则

一个对象应该和其他对象保持最少的了解。降低类之间的耦合。

### 依赖倒转原则

依赖抽象，不依赖具体实现。模块都应该依赖于抽象，而不是相互依赖。

### 单一职责原则

一个类只负责一个功能领域中的职责。强内聚，低耦合。

### 开放封闭原则

对扩展开放，对修改关闭。应该在尽量不修改原来代码的情况下进行扩展。新的升级不应该影响老代码功能。

### 里氏代换原则

任何基类出现的地方，一定能将其换成子类，并且功能不受影响，这样基类才是真正被复用。

### 接口隔离原则

接口尽量细化，不要臃肿，接口中的方法尽可能少，减弱类之间的依赖关系。

### 合成/聚合复用原则

尽量使用合成/聚合达成复用目的，少用继承。明确是is a的情况再使用继承，has a的情况用合成/聚合。
聚合：较弱的拥有关系，整体和部分可以不相关，各自管理生命周期。羊是羊群的一部分：聚合。
合成：较强的拥有关系，严格的整体-部分关系，部分和整体的生命周期是一致的。羊腿是羊的一部分：合成。

## 创建型模式

对类的实例化过程进行抽象，将对象创建与使用进行分离。不需要了解具体实现细节，是需要知道获取对象实例的接口即可。创建型模式隐藏了类实例的创建细节，通过隐藏对象如何被创建和组合在一起使得整个系统独立。

### 简单工厂模式

***简介***：也称为静态工厂模式（静态函数），专门定义一个类负责创建其他类的实例，根据参数的不同返回不同的类实例，被创建的实例通常具有相同的父类。
***优点***：使用者只需要知道输入的参数即可，不需要知道创建细节，实现了对象创建与对象使用的分离。
***缺点***：简单工厂本身不够灵活，增加产品需要修工厂逻辑，产品越多，逻辑越复杂。
***用途***：适用于产品种类较少，不关心创建过程的场景中。

### 工厂方法模式

***简介***：为工厂定义一个公共父类，这样在有新产品时，不需要修改工厂逻辑，只需要再加一个工厂子类即可。
***优点***：是简单工厂模式的进一步推广和抽象，工厂基类可以定义多个工厂方法被工厂子类继承，更具设计扩展性。
***缺点***：增加新产品时，要同步增加一个工厂子类，类的个数成对增加，加重了系统负担和编译开销，增加整体的复杂性。
***用途***：适用于更进一步的，连具体产品类型都不需要知道，只需要知道需要哪种工厂子类的场景中；适用于一个类通过其子类创建对象，这个类就可以被设计为工厂基类。

### 抽象工厂模式

***简介***：前述工厂生产的都是一个类型的产品，具有共同的父类。如果要生产其他种类的产品（和之前的产品不具有共同父类），就需要使用抽象工厂方法。
***优点***：前述工厂模式的抽象与扩展，隔离了具体类的生成，实现了高耦合低内聚的目的。
***缺点***：：类似于工厂方法模式，添加新的产品时需要成对的添加；此外，如果想要创建新的产品种类，需要进行大面积的修改，因为抽象工厂实际上先规定了生产的产品类型，每个具体工厂都会生产所有种类的产品。
***用途***：适用于系统中有两个及以上的产品族，而每次只使用其中一个（每次使用其中一个具体工厂），属于同一工厂的全部产品将在一起使用，例如更换界面主题时，按钮，文本框，背景色就相当与同属于主题这一工厂的不同产品，并且在一起使用。

### 建造者模式

***简介***：复杂对象，拥有一系列的成员属性，并且可能存在限制条件，赋值顺序等问题，而用户并不需要知道内部细节，只需要能够拿到这一对象即可。类似小汽车，需要各个零部件装配，这时使用建造者模式组合各部件，返回给客户完整对象。
***优点***：不需要知道内部组成细节，同一个创建过程根据需求不同可以得到不同的产品对象；可以通过不同的建造者得到不同的产品；创建过程分布解耦，更加方便进行管理。（KFC点单，产品包含食物和饮料，根据不同的需求，生成不同的产品对象，再组合；游戏的地图以及人物创建）
***缺点***：建造者所创建的产品一般具有较多共同点，组成部分相似，如果产品之间差异较大则不适合。
***用途***：适用于产品对象内部具有复杂结构，包含多个成员属性，存在相互依赖和生成顺序的问题；创建过程独立，引入指挥者角色，将对象的创建过程封装在指挥者中。

### 原型

***简介***：一个对象通过克隆的方式在创建一个新对象，外部不用关心新对象如何创建，只需要调用clone函数就可以得到一个新对象。关键就是深拷贝，C++中可以考虑使用拷贝构造函数实现。
***优点***：利用clone接口简化创建过程，无需在外部创建。
***缺点***：深拷贝代码可能比较复杂，已有类修改时，需要同步修改clone方法。
***用途***：适用于创建新对象成本较大，可以对已有对象进行复制。

### 单例（懒：用到的时候创建实例，在getinstance中[线程安全问题]/饿：类加载时就创建，在cpp文件中instance直接=new）

***简介***：系统中只能存在唯一一个实例，可以在全局范围内提供访问。单例类构造函数私有，外部无法创建实例化，内部提供一个静态实例变量和一个静态的公有方法，单例类检验实例是否存在并实例化自己存储在变量中。
***优点***：提供了对唯一实例的受控访问；系统内部仅有一个实例，节约资源；可以扩展得到指定个数的对象实例（多例模式）。
***缺点***：职责过重，既是工厂，也是产品；没有抽象，难以扩展；不要滥用单例。
***用途***：适用于系统只需要一个对象，并且系统只需要一个公共访问点，除此以外，不能通其他方式访问。

## 结构型模式

通过将类或者对象结合在一起，形成更强大，更复杂的结构。
**类结构型**：类之间的组合，一般是继承实现关系；**对象结构型**：类与对象间的组合，一般是关联关系，在一个类中定义另一个类的实例化对象，进一步调用其方法。尽可能用关联关系代替继承关系。

### 适配器模式（包装器）

***简介***：类似于电源适配器，现有类的接口与客户类所期望的不同，但又希望使用现有类的功能。所以需要适配器对现有类的接口进行转化包装，提供给客户类。包装类就是适配器，被包装的对象就是适配者，客户类通过调用目标接口类的方法实现业务功能。
***优点***：目标类与适配器类解耦，增强了类的透明性和复用性，提升灵活性和扩展性
***缺点***：类适配器模式需要多重继承，继承接口类和适配者类，受限于编程语言；对象适配器模式很难替换适配者类的方法。
***用途***：适用于系统需要使用现有类，但这些类的接口不符合系统需要；建立一个可重复使用的类，用于与一些没什么关联的类一起工作。

### 桥接模式

***简介***：对于有两个维度变化的系统，针对这两个维度分别抽象设计，并在抽象类层面进行关联。例如绘制颜色不同的不同形状，颜色和形状是两个独立变化的维度，如果每一种颜色的形状都提供一个类，代码会更多，扩展性也比较差。使用桥接模式减少代码量，降低耦合性。
***优点***：分离抽象接口及其实现；类似于多重继承的效果，但避免了多重继承的复用性差的问题；提高灵活性和可扩展性。
***缺点***：增加理解和设计难度，要在抽象层建立关联关系；需要找到独立变化的两个维度。
***用途***：适用于存在两个独立变化且都需要进行扩展的维度的类，或者作为多重继承的替代方案。可以自由的进行两个维度的动态耦合。

### 装饰器模式（也是一种包装器）

***简介***：给类或对象增加一个行为，可以通过继承一个现有类的方式，但这种方式不具有动态性，不能动态决定是否增加以及何时增加。通过关联方式将一个类的对象嵌入到另一个类或对象中，这个嵌入的对象就是装饰器。（变形金刚）
***优点***：更加灵活的扩展对象功能；可以通过运行时加载的方式，实现不同的行为，并可扩展得到功能更多的对象。
***缺点***：会产生很多小的对象和具体的装饰器类，在出错时排查更困难，加大学习理解难度。
适用于不影响其他对象的情况下，动态透明的增加、撤销功能；在不适合继承（final）的情况下完成继承可以做到的功能。

### 外观模式

***简介***：外部与子系统的通信需要一个统一的接口，定义外观类，封装多个子系统并提供一个功能接口。
***优点***：对外屏蔽子系统，使用起来更加方便，调用外观类的接口就可以完成子系统功能；子系统的调整只影响外观类内部逻辑，不影响对外使用接口；减少了编译依赖。
***缺点***：不能很好的限制外部对子系统的使用，限制太多就无法使用外观类做统一接口。
***用途***：适用于需要为复杂子系统提供简单接口以供外界访问。解耦外部客户端与子系统，降低整体耦合度。

### 享元模式

***简介***：通过共享技术实现相同或相似对象的重用，一般需要创建一个工厂，维护一个享元池，用于存储具有相同状态的享元对象。这样可以减少类和对象的个数，实现最大程度的细粒度对象复用。
***优点***：减少对象数量，相同状态的对象只保存一份。
***缺点***：需要分离出可以共享的和不可以共享的，增加系统复杂度。
***用途***：适用于一个系统有大量相同或相似的对象，重复使用这些对象（文档中重复出现的图片，共享图片，每次设置位置）；对象的状态可以外部化并传入对象中，这样可以帮助拆解。

### 代理模式

***简介***：在不能直接引用或不想直接引用某个对象的时候，通过在代理类中引用那个对象，外部通过代理类来间接调用对象的服务。并且可以在代理类中去掉不需要的服务或者增加新的服务内容。
***优点***：能够协调调用者和被调用者，降低系统耦合度；代理可以控制对真实对象的使用权限；远程代理让用户忽略网络的感觉，虚拟代理通过一个小对象临时代替大对象，让大对象的加载在后台完成，不影响前台使用。
***缺点***：增加了一个代理类，可能会造成处理速度变慢。
***用途***：远程访问，虚拟代理（小对象临时替代大对象），保护代理（控制访问权限）等情况。

## 行为型模式
在不同对象之间划分责任，重点关注它们之间的相互作用。包括通过继承关系分配父类与子类的职责，通过关联关系聚合对象的来分配行为。

### 职责链模式

***简介***：对请求的发送者和接受者进行解耦。当有多个对象都可以接收请求时，将他们串成链，请求沿着链进行传播，客户端不需要知道最后是谁处理，只需要提交上去即可。
***优点***：降低了耦合度，增强了请求处理的灵活性，便于扩展。
***缺点***：可能会出现请求的循环，不便于调试，请求不保证一定会被处理。
***用途***：适用于多个对象可以处理同一个请求，具体由谁处理在运行时确定；不明确接收者的时候向多个对象提交请求。

### 命令模式（动作模式/事物模式）

***简介***：将请求的发送者和接收者完全解耦，发送者和接收者没有直接引用关系，发送请求的对象只需要知道如何发送请求，不需要知道如何完成请求。请求本身被封装为一个对象，关键在于引入抽象命令接口。
***优点***：可以降低系统的耦合度；方便加入新的命令，只需要再加一个命令子类；方便实现命令的do和undo。
***缺点***：每个具体命令都对应一个子类，导致系统中存在大量的命令类。
***用途***：适用于调用者和接收者解耦，可以将一组操作组合实现宏命令，需要对命令/请求do和undo。

### 解释器模式

***简介***：给定一个语言，规定文法表示，通过解释器解析这一段句子的含义。
***优点***：扩展性较好。
***缺点***：引起类膨胀，解释存在递归调用，难以调试。
***用途***：一般较少使用，正则表达式解析、运算表达式解析、编译器等。

### 迭代器模式

***简介***：提供一个对象顺序访问另一个对象中的一系列数据，而不对外暴露该对象的内部表示形式，就像STL中的迭代器一样。
***优点***：遍历任务抽象为迭代器类，简化了对象类本身，为遍历不同内部结构的对象提供了封装良好的统一接口。
***缺点***：增加了类和对象的个数，提升系统复杂性。
***用途***：适用于不想让外部直接获取类内数据结构但又需要获取数据，将内部数据结构的遍历方式进行封装（或者封装内部数据结构本身的迭代器）。

### 中介者模式

***简介***：用一个中介对象封装一系列对象的交互，使各个对象不需要显示相互引用，降低耦合程度。
***优点***：简化了对象交互，降低耦合。
***缺点***：复杂的交互细节放在了中介类中，导致中介类变得复杂。
***用途***：适用于系统中的对象之间存在比较复杂的引用关系；引入中介类封装多个类中的行为，减少子类生成。

### 备忘录模式

***简介***：不破坏封装的前提下，捕获对象内部状态，并在对象外保存这个状态。通过一个备忘录类进行记录，对象本身不和备忘录类关联，而是和备忘录管理类关联，备忘录管理类负责存储备忘录类，并能够获取备忘录类中保存的状态数据。
***优点***：提供一种可以回滚数据的方式，并且用户不需要关心数据的具体保存方式。
***缺点***：如果保存数据很多，会消耗很多资源，并且每次保存都消耗时间空间。
***用途***：适用于需要保存/恢复数据的场景，提供回滚操作。

### 观察者模式（发布-订阅）

***简介***：定义对象间的一种一对多依赖关系，使得每当一个对象状态发生改变时，其相关依赖对象皆得到通知并被自动更新。
***优点***：支持广播通信，抽象出了消息更新接口，解耦了观察目标和观察者。
***缺点***：通知耗时；循环依赖会循环调用导致崩溃；只知道变化，但不知道如何发生的变化。
***用途***：适用于一对多通信，并且不确定具体数量的时候；链式触发机制。

### 状态模式

***简介***：当一个对象的内在状态改变时允许改变其行为，状态抽象为类，动作执行者中包含状态类指针，状态子类中的执行函数传入动作执行者形参，完成自己状态对应的操作，并改变动作执行者的状态。状态子类可以按照单例设置，这样在频繁改变状态时不需要多次申请内存。
***优点***：封装了状态转换规则，抽象出了每个状态和对应的动作，避免混在一起出现巨大的条件语句块。
***缺点***：增加类和对象的个数，状态多会导致结构和实现都比较复杂。
***用途***：适用于对象行为依赖于当前状态，并可根据状态改变行为。

### 策略模式

***简介***：某个功能的实现可以有多种方法，每种方法可以看作一个策略，根据环境或条件的不同，动态选择策略（set）来完成任务。具体来说，把每种方法封装作为一个类，方法之间可以相互替换，用户可以通过设置选择使用哪种策略。
***优点***：可以灵活选择策略，灵活增删策略。
***缺点***：用户需要知道所有的策略类，并自行决定使用哪个，一定程度增加了使用难度。
***用途***：适用于系统中有许多类，区别只有他们的行为，允许动态选择使用哪一种行为。

### 模板方法模式

***简介***：通过继承，将步骤稳定，但具体操作可能变化的方法延迟到子类中实现，基类可以实现部分默认的步骤。不同子类可以选择重写不同的步骤，最终形成不同的方法。区别于策略模式，模板方法是继承，策略模式是组合。
***优点***：去除代码的重复，便于扩展新的方法。
***缺点***：类的个数会增加，每有一个新方法就要加一个对应的子类。
***用途***：适用于多个子类共有方法，并且执行逻辑相同，只有内部操作细节不同。

### 访问者模式

***简介***：将数据结构与数据操作分离，解决稳定的数据结构和易变的操作耦合的问题。在被访问的类中加入一个接收访问者的接口，将自身传入给访问者。访问者中针对每一个种类的被访问者提供一个访问函数，被访问者实现对应自身的访问者函数。
***优点***：符合单一职责原则，灵活扩展，新的访问操作不影响类对象。
***缺点***：对访问者公开细节，违反迪米特原则；实现依赖具体类而不是抽象，违反依赖倒置原则。
***用途***：适用于数据结构对应的类很少改变，种类基本固定，但需要经常定义新操作；进行很多不同并且不相关的操作，避免操作污染对象。
